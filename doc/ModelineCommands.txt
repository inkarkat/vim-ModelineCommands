*ModelineCommands.txt*  Extended modelines that allow the execution of arbitrary Vim commands.

		     MODELINE COMMANDS    by Ingo Karkat
							*ModelineCommands.vim*
description			|ModelineCommands-description|
usage				|ModelineCommands-usage|
installation			|ModelineCommands-installation|
configuration			|ModelineCommands-configuration|
limitations			|ModelineCommands-limitations|
known problems			|ModelineCommands-known-problems|
todo				|ModelineCommands-todo|
history				|ModelineCommands-history|

==============================================================================
DESCRIPTION					*ModelineCommands-description*


SEE ALSO								     *
(Plugins offering complementary functionality, or plugins using this library.)

RELATED WORKS								     *

- let-modeline.vim (vimscript #83) extends the modeline feature to the
  assignment of variables

==============================================================================
USAGE						      *ModelineCommands-usage*

Modeline commands are read and executed after the buffer has been read (i.e.
on |BufReadPost|). The first and last lines of the buffer are searched for
them.
						     *ModelineCommands-syntax*
The modeline command syntax is similar to the second form of the built-in
|modeline| feature, using the vimcommand: prefix instead of vim:
The command(s) (you can both concatenate multiple Ex commands via |:bar|
and/or have separate modeline commands on multiple lines) are concluded with a
":" (followed by an optional command digest for verification of its integrity,
also concluded with a ":"); that means that colons within the command must be
escaped by preceding them with a backslash.

    [text]{white}{vimcommand:|VimCommand:}[!][white]:{commands}:[text]
    [text]{white}{vimcommand:|VimCommand:}[!][white]:{commands}:[white]{digest}[white]:[text]

[text]			any text or empty
{white}			at least one blank character (<Space> or <Tab>)
{vimcommand:|VimCommand:}the string "vimcommand:" or "VimCommand:"
[!]			optional marker for |:silent!| execution
[white]			optional white space
{commands}		Ex commands
:[white]{digest}[white]	optional hash over {command} and
			|g:ModelineCommands_Secret| concatenated together, to
			verify the integrity of {command}
:			a colon
[text]			any text or empty


EXAMPLE						    *ModelineCommands-example*
   /* vimcommand: let b:frobnize = "on": */ ~
   /* vimcommand: IndentConsistencyCopOff: */ ~
   /* vimcommand: echomsg "modeline commands\: an example" | version:7fab292cd: */ ~

==============================================================================
INSTALLATION				       *ModelineCommands-installation*

This script is packaged as a |vimball|. If you have the "gunzip" decompressor
in your PATH, simply edit the *.vmb.gz package in Vim; otherwise, decompress
the archive first, e.g. using WinZip. Inside Vim, install by sourcing the
vimball or via the |:UseVimball| command. >
    vim ModelineCommands*.vmb.gz
    :so %
To uninstall, use the |:RmVimball| command.

DEPENDENCIES				       *ModelineCommands-dependencies*

- Requires Vim 7.0 or higher.
- Requires the |ingo-library.vim| plugin (vimscript #4433), version 1.025 or
  higher.

==============================================================================
CONFIGURATION				      *ModelineCommands-configuration*

For a permanent configuration, put the following commands into your |vimrc|:
					      *g:ModelineCommands_FilePattern*
If you want to search for modeline commands only in certain files, you can
specify |autocmd-patterns| instead of the default "*". This must be set before
the plugin is sourced: >
    let g:ModelineCommands_FilePattern = '*.h,*.c,*.cpp'
<
		*g:ModelineCommands_FirstLines* *g:ModelineCommands_LastLines*
The number of lines at the start of the buffer that are searched for modeline
commands; the default is 'modelines' >
    let g:ModelineCommands_FirstLines = 10
<
As arbitrary Vim commands can do harm to your system (with |:!| and :call
system(...), you can execute any external command!), there are two kinds of
gatekeepers:

   *b:ModelineCommands_CommandValidator* *g:ModelineCommands_CommandValidator*
Modeline commands that do not have a digest attached can be filtered based on
the command itself. You can configure a Funcref that takes the command as an
argument, and returns whether it should be allowed: >
    let g:ModelineCommands_CommandValidator = function('...')
The validator probably will attempt to match the passed command with a regexp.
Note that blacklisting is unreliable, as there are many ways that malicious
commands can be written. Better just allow certain, harmless commands, and be
strict with your regular expression. The default validator tries to match the
command with a single regular expression:
*b:ModelineCommands_ValidCommandPattern* *g:ModelineCommands_ValidCommandPattern*
Its default just allows simple |:let| and |:echomsg| of numbers and strings.

       *b:ModelineDigests_DigestValidator* *g:ModelineDigests_DigestValidator*
Both the modeline command and the digest are passed to this validator. The
validator should re-generate the digest from the passed command and a secret,
and compare that with the passed digest.
	 *b:ModelineCommands_DigestPattern* *g:ModelineCommands_DigestPattern*
The format of the digest depends on the digest function, typically it is a
hexadecimal string. Vim's |sha256()| function returns a 64-digit hex number.
The default digest validator accepts shorter digests, so you can truncate the
long number in the modeline. How short (and therefore how insecure) the
digest can be can be configured in the digest pattern. >
    let g:ModelineCommands_DigestPattern = '\x\{8,64}'
<		       *b:ModelineCommands_Secret* *g:ModelineCommands_Secret*
The default digest validator requires a secret string. Either put that
directly into the variable, or assign a Funcref that will return it. If a
person knows the secret, he can create valid digests for arbirary modeline
commands, and make you execute the command when you open the file, so guard
this secret carefully!

Validation establishes a certain level of security. If it fails, the command
will be rejected. You can still configure the policy for accepted commands,
one of "no" (discarded), "ask" (query you before execution), "yes" (allow).
 *b:ModelineCommands_AcceptUnvalidated* *g:ModelineCommands_AcceptUnvalidated*
Policy for commands where no (command or digest-based) validator is configured:
    let g:ModelineCommands_AcceptUnvalidated = "ask"
     *b:ModelineCommands_AcceptValidated* *g:ModelineCommands_AcceptValidated*
Policy for commands that passed a (command or digest-based) validator: >
    let g:ModelineCommands_AcceptValidated = "yes"
<
==============================================================================
LIMITATIONS					*ModelineCommands-limitations*

KNOWN PROBLEMS				     *ModelineCommands-known-problems*

TODO						       *ModelineCommands-todo*

IDEAS						      *ModelineCommands-ideas*

==============================================================================
HISTORY						    *ModelineCommands-history*

GOAL
First published version.

0.01	13-Jul-2016
Started development.

==============================================================================
Copyright: (C) 2016 Ingo Karkat
The VIM LICENSE applies to this plugin; see |copyright|.

Maintainer:	Ingo Karkat <ingo@karkat.de>
==============================================================================
 vim:tw=78:ts=8:ft=help:norl:
